### IScroll的使用方法

1. 引入iscroll库
2. new一个新的iscroll对象
3. **注意：**class `wrap` 下的第一个标签，为iscroll的滑动区域

```
<script src="./iscroll.js"></script>
<script>
let scroll = new IScroll('.wrap',{可选的参数})
</script>
<body>
    <div class="wrap">
      <div class="content"></div>
    </div>
</body>
```



### IScroll的常用参数

- bounce 回弹
- bounceTime 回弹时间
- scrollX/scrollY 允许水平拖拽/竖直拖拽
- freeScroll 允许同时上下左右拖拽（解除方向锁定）
- startX/startY 开始的时候对象距离left/top的距离
- mouseWheel 允许鼠标滑轮
- momentum 物理引擎



### IScroll事件

*iscroll的事件绑定方法类似于jQuery*

**方法：**`scroll.on('事件名称',function(){})`

**常用的事件：**

- `beforeScrollStart` 按下的一瞬间，还没有开始滑动
- `scrollStart` 开始滑动
- `scroll` 滑动的过程，最重要
- `scrollEnd` 滑动结束
- `scrollCancel` 按下去后并没有开始滑动，然后抬起，表示取消滑动

---

 ### IScroll-probe.js

*这个版本是iscroll的拓展，主要区别在于可以监控重要的scroll过程*

**方法：**

1. 引入probe版的iscroll`<script src="iscroll-probe.js"></script>`
2. 在new对象的时候加上probeType参数，`let iscroll=new IScroll('.wrap', {probeType: 2});`
3. `probeType` 的值为1、2、3，区别在于：
   1. `probeType: 1` 优先级最低，使用定时器来监控。
   2. `probeType: 2` 优先级比较高，使用touchmove(mousemove)来监控scroll事件（除了在momentum和bounce中）。常用。
   3. `probeType: 3` 优先级最高，不再使用transition。在松开手指后的回弹过程中，使用JS来继续监控。性能低。

> `probeType: 1` has no impact on performance. The `scroll` event is fired only when the scroller is not busy doing its stuff.
>
> `probeType: 2` always executes the `scroll` event except during momentum and bounce. This resembles the native `onScroll` event.
>
> `probeType: 3` emits the `scroll` event with a to-the-pixel precision. Note that the scrolling is forced to `requestAnimationFrame` (ie: `useTransition:false`).



### 下拉刷新

自定义一个 `scrollYBeforeRelease` 送开手指时，那一刻的坐标点

`iscroll.endTime` 松开手指时，那一刻的时间

`scrollTo` 只能在对象静止的时候跳到指定位置，不能在move的时候直接到达指定位置

