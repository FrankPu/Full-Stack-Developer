const http=require('http');
//const Event=require('events').EventEmitter;

module.exports=class {
  constructor(){
    //this.__ev=new Event();
    this.__queue=[];

    this.__server=http.createServer((req, res)=>{
      const _this=this;

      if(this.__queue.length>0){
        //准备ctx对象
        const ctx={
          req, res,
          request: {},
          response: {
            body: ''
          }
        };






        _run(0);

        async function _run(n, cb){
          let fn=_this.__queue[n];
          let str=fn.constructor.toString();

          /*if(str.indexOf('GeneratorFunction')!=-1){
            console.log('生成器函数');
          }else */if(str.indexOf('AsyncFunction')!=-1){
            await fn(ctx, function (){
              return new Promise((resolve, reject)=>{
                _run(n+1, function (){
                  resolve();
                });
              });
            });
          }else if(str.indexOf('Function')!=-1){
            fn(ctx, function (){
              _run(n+1);
            });
          }

          cb && cb();
        }

      }else{
        res.writeHeader(404);
        res.write('Not Found');
        res.end();
      }
    });
  }

  listen(port=80){
    this.__server.listen(port);
  }

  use(fn){
    let str=fn.constructor.toString();

    if(str.indexOf('GeneratorFunction')!=-1){
      console.warn('koa中generator已经抛弃了，你赶紧改改吧');
    }

    this.__queue.push(fn);

    //this.__ev.

    /*if(str.indexOf('GeneratorFunction')!=-1){
      console.log('生成器函数');
    }else if(str.indexOf('AsyncFunction')!=-1){
      console.log('Async函数');
    }else if(str.indexOf('Function')!=-1){
      console.log('普通函数');
    }*/
  }
};
